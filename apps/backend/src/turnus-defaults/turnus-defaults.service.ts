import {
  Injectable,
  NotFoundException,
  ConflictException,
  BadRequestException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { LegacyDatabasesService } from '../legacy-databases/legacy-databases.service';
import {
  CreateTurnusDefaultDto,
  UpdateTurnusDefaultDto,
  FindTurnusDefaultsDto,
  AnalyzeHistoryDto,
  DataSource,
  DayOfWeek,
} from './dto';
import { Prisma } from '@prisma/client';
import * as mysql from 'mysql2/promise';

export interface HistoryAnalysisResult {
  driverId: number;
  driverName: string;
  turnusName: string;
  lineNumber: string | null;
  shiftNumber: number | null;
  dayOfWeek: DayOfWeek | null;
  usageCount: number;
  usagePercentage: number;
  confidenceScore: number;
  recommendation: string;
}

@Injectable()
export class TurnusDefaultsService {
  private readonly logger = new Logger(TurnusDefaultsService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly legacyDatabasesService: LegacyDatabasesService,
  ) {}

  /**
   * Kreira novi turnus default
   */
  async create(createDto: CreateTurnusDefaultDto, userId: number) {
    // Proveri da li vozaƒç postoji
    const driver = await this.prisma.user.findUnique({
      where: { id: createDto.driverId },
      include: {
        userGroup: true,
      },
    });

    if (!driver) {
      throw new NotFoundException(`Vozaƒç sa ID ${createDto.driverId} nije pronaƒëen`);
    }

    if (!driver.userGroup?.driver) {
      throw new BadRequestException(`Korisnik ${driver.firstName} ${driver.lastName} nije vozaƒç`);
    }

    // Automatski izraƒçunaj prioritet na osnovu nivoa specifiƒçnosti
    const priority = this.calculatePriority(
      createDto.lineNumberForDisplay,
      createDto.shiftNumber,
      createDto.dayOfWeek,
    );

    try {
      const turnusDefault = await this.prisma.turnusDefaultPerDriver.create({
        data: {
          driverId: createDto.driverId,
          turnusName: createDto.turnusName,
          lineNumberForDisplay: createDto.lineNumberForDisplay || null,
          shiftNumber: createDto.shiftNumber || null,
          dayOfWeek: createDto.dayOfWeek || null,
          priority: createDto.priority || priority,
          isActive: createDto.isActive ?? true,
          note: createDto.note || null,
          createdBy: userId,
          updatedBy: userId,
        },
        include: {
          driver: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          creator: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
            },
          },
        },
      });

      // Konvertuj Decimal tipove u brojeve za frontend
      return {
        ...turnusDefault,
        usagePercentage: turnusDefault.usagePercentage ? Number(turnusDefault.usagePercentage) : 0,
        confidenceScore: turnusDefault.confidenceScore ? Number(turnusDefault.confidenceScore) : 0,
      };
    } catch (error) {
      if (error.code === 'P2002') {
        throw new ConflictException(
          'Default sa istim parametrima veƒá postoji za ovog vozaƒça',
        );
      }
      throw error;
    }
  }

  /**
   * Pronalazi sve defaults sa opcijama filtriranja
   */
  async findAll(query: FindTurnusDefaultsDto) {
    const where: Prisma.TurnusDefaultPerDriverWhereInput = {};

    if (query.driverId !== undefined) {
      where.driverId = query.driverId;
    }

    if (query.turnusName) {
      where.turnusName = {
        contains: query.turnusName,
      };
    }

    if (query.lineNumberForDisplay) {
      where.lineNumberForDisplay = query.lineNumberForDisplay;
    }

    if (query.shiftNumber !== undefined) {
      where.shiftNumber = query.shiftNumber;
    }

    if (query.dayOfWeek) {
      where.dayOfWeek = query.dayOfWeek;
    }

    if (query.isActive !== undefined) {
      where.isActive = query.isActive;
    }

    if (query.autoGenerated !== undefined) {
      where.autoGenerated = query.autoGenerated;
    }

    const defaults = await this.prisma.turnusDefaultPerDriver.findMany({
      where,
      include: {
        driver: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        creator: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
        updater: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
      orderBy: [
        { driverId: 'asc' },
        { priority: 'asc' },
        { confidenceScore: 'desc' },
      ],
    });

    // Konvertuj Decimal tipove u brojeve za frontend
    return defaults.map((d) => ({
      ...d,
      usagePercentage: d.usagePercentage ? Number(d.usagePercentage) : 0,
      confidenceScore: d.confidenceScore ? Number(d.confidenceScore) : 0,
    }));
  }

  /**
   * Pronalazi jedan default po ID-u
   */
  async findOne(id: number) {
    const turnusDefault = await this.prisma.turnusDefaultPerDriver.findUnique({
      where: { id },
      include: {
        driver: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        creator: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
        updater: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    if (!turnusDefault) {
      throw new NotFoundException(`Turnus default sa ID ${id} nije pronaƒëen`);
    }

    // Konvertuj Decimal tipove u brojeve za frontend
    return {
      ...turnusDefault,
      usagePercentage: turnusDefault.usagePercentage ? Number(turnusDefault.usagePercentage) : 0,
      confidenceScore: turnusDefault.confidenceScore ? Number(turnusDefault.confidenceScore) : 0,
    };
  }

  /**
   * A≈æurira postojeƒái default
   */
  async update(id: number, updateDto: UpdateTurnusDefaultDto, userId: number) {
    // Proveri da li default postoji
    await this.findOne(id);

    // Ako se menjaju kljuƒçni parametri, recalculate priority
    let priority: number | undefined;
    if (
      updateDto.lineNumberForDisplay !== undefined ||
      updateDto.shiftNumber !== undefined ||
      updateDto.dayOfWeek !== undefined
    ) {
      const existing = await this.prisma.turnusDefaultPerDriver.findUnique({
        where: { id },
      });

      if (existing) {
        priority = this.calculatePriority(
          updateDto.lineNumberForDisplay ?? existing.lineNumberForDisplay,
          updateDto.shiftNumber ?? existing.shiftNumber,
          updateDto.dayOfWeek ?? existing.dayOfWeek as DayOfWeek,
        );
      }
    }

    try {
      const updated = await this.prisma.turnusDefaultPerDriver.update({
        where: { id },
        data: {
          ...updateDto,
          priority: updateDto.priority ?? priority,
          updatedBy: userId,
        },
        include: {
          driver: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
          updater: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
            },
          },
        },
      });

      // Konvertuj Decimal tipove u brojeve za frontend
      return {
        ...updated,
        usagePercentage: updated.usagePercentage ? Number(updated.usagePercentage) : 0,
        confidenceScore: updated.confidenceScore ? Number(updated.confidenceScore) : 0,
      };
    } catch (error) {
      if (error.code === 'P2002') {
        throw new ConflictException(
          'Default sa istim parametrima veƒá postoji za ovog vozaƒça',
        );
      }
      throw error;
    }
  }

  /**
   * Bri≈°e default
   */
  async remove(id: number) {
    // Proveri da li default postoji
    await this.findOne(id);

    await this.prisma.turnusDefaultPerDriver.delete({
      where: { id },
    });

    return {
      success: true,
      message: 'Turnus default je uspe≈°no obrisan',
    };
  }

  /**
   * Pronalazi najbolji matching default za dati kontekst
   * Vraƒáa null ako nema nijedan aktivan default
   */
  async findBestMatch(
    driverId: number,
    lineNumber?: string,
    shiftNumber?: number,
    dayOfWeek?: DayOfWeek,
  ) {
    const where: Prisma.TurnusDefaultPerDriverWhereInput = {
      driverId,
      isActive: true,
      AND: [],
    };

    // Kreiraj WHERE uslove za svaki nivo specifiƒçnosti
    const conditions: Prisma.TurnusDefaultPerDriverWhereInput[] = [];

    // Level 1-8: Razliƒçite kombinacije parametara
    if (lineNumber && shiftNumber && dayOfWeek) {
      conditions.push({
        lineNumberForDisplay: lineNumber,
        shiftNumber,
        dayOfWeek,
      });
    }

    if (lineNumber && shiftNumber) {
      conditions.push({
        lineNumberForDisplay: lineNumber,
        shiftNumber,
        dayOfWeek: null,
      });
    }

    if (lineNumber && dayOfWeek) {
      conditions.push({
        lineNumberForDisplay: lineNumber,
        shiftNumber: null,
        dayOfWeek,
      });
    }

    if (shiftNumber && dayOfWeek) {
      conditions.push({
        lineNumberForDisplay: null,
        shiftNumber,
        dayOfWeek,
      });
    }

    if (lineNumber) {
      conditions.push({
        lineNumberForDisplay: lineNumber,
        shiftNumber: null,
        dayOfWeek: null,
      });
    }

    if (shiftNumber) {
      conditions.push({
        lineNumberForDisplay: null,
        shiftNumber,
        dayOfWeek: null,
      });
    }

    if (dayOfWeek) {
      conditions.push({
        lineNumberForDisplay: null,
        shiftNumber: null,
        dayOfWeek,
      });
    }

    // Fallback: samo turnus bez specifiƒçnosti
    conditions.push({
      lineNumberForDisplay: null,
      shiftNumber: null,
      dayOfWeek: null,
    });

    // Pronaƒëi prvi matching default (ORDER BY priority ASC, confidence DESC)
    const match = await this.prisma.turnusDefaultPerDriver.findFirst({
      where: {
        ...where,
        OR: conditions,
      },
      orderBy: [
        { priority: 'asc' },
        { confidenceScore: 'desc' },
        { usageCount: 'desc' },
      ],
      include: {
        driver: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    // Konvertuj Decimal tipove u brojeve za frontend
    if (match) {
      return {
        ...match,
        usagePercentage: match.usagePercentage ? Number(match.usagePercentage) : 0,
        confidenceScore: match.confidenceScore ? Number(match.confidenceScore) : 0,
      };
    }

    return null;
  }

  /**
   * Vraƒáa listu svih jedinstvenih linija iz date_travel_order tabele
   */
  async getLines(): Promise<string[]> {
    const lines = await this.prisma.dateTravelOrder.findMany({
      select: {
        lineNo: true,
      },
      distinct: ['lineNo'],
      orderBy: {
        lineNo: 'asc',
      },
    });

    return lines.map((l) => l.lineNo).filter((l): l is string => l !== null);
  }

  /**
   * Analizira istoriju vo≈ænji iz obe baze i vraƒáa preporuke za defaults
   */
  async analyzeHistory(dto: AnalyzeHistoryDto, userId: number): Promise<HistoryAnalysisResult[]> {
    const {
      startDate,
      endDate,
      driverId,
      driverIds,
      minUsageCount = 5,
      minConfidenceScore = 70,
      source = DataSource.MYSQL,
      lineNumber
    } = dto;

    // Konstrui≈°i WHERE klauzulu za filtriranje vozaƒça
    let driverFilter = '';
    if (driverId) {
      driverFilter = `AND dto.driver_id = ${driverId}`;
    } else if (driverIds && driverIds.length > 0) {
      driverFilter = `AND dto.driver_id IN (${driverIds.join(',')})`;
    }

    // Konstrui≈°i WHERE klauzulu za filtriranje po liniji
    let lineFilter = '';
    if (lineNumber) {
      lineFilter = `AND dto.line_no = '${lineNumber}'`;
    }

    // Ako je izvor legacy, koristi drugu logiku
    if (source === DataSource.LEGACY) {
      return this.analyzeHistoryFromLegacy(dto, userId);
    }

    // Query za analizu iz na≈°e MySQL baze
    const ourDbQuery = `
      SELECT
        dto.driver_id as driverId,
        CONCAT(u.first_name, ' ', u.last_name) as driverName,
        SUBSTRING_INDEX(SUBSTRING_INDEX(dto.comment, 'Turnus: ', -1), ',', 1) as turnusName,
        dto.line_no as lineNumber,
        CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(dto.comment, 'Smena: ', -1), ',', 1) AS UNSIGNED) as shiftNumber,
        CASE DAYOFWEEK(dto.start_date)
          WHEN 1 THEN 'Nedelja'
          WHEN 2 THEN 'Ponedeljak'
          WHEN 3 THEN 'Utorak'
          WHEN 4 THEN 'Sreda'
          WHEN 5 THEN 'ƒåetvrtak'
          WHEN 6 THEN 'Petak'
          WHEN 7 THEN 'Subota'
        END as dayOfWeek,
        COUNT(*) as usageCount
      FROM date_travel_order dto
      INNER JOIN users u ON dto.driver_id = u.id
      WHERE dto.start_date BETWEEN ? AND ?
        AND dto.realised = 1
        ${driverFilter}
        ${lineFilter}
        AND dto.comment LIKE '%Turnus:%'
        AND dto.comment LIKE '%Smena:%'
      GROUP BY dto.driver_id, turnusName, dto.line_no, shiftNumber, dayOfWeek
      HAVING usageCount >= ${minUsageCount}
    `;

    const results = await this.prisma.$queryRawUnsafe<any[]>(
      ourDbQuery,
      startDate,
      endDate,
    );

    // Izraƒçunaj statistiku i confidence score za svaki rezultat
    const analysis: HistoryAnalysisResult[] = [];

    for (const row of results) {
      // Izraƒçunaj ukupan broj vo≈ænji za vozaƒça u periodu
      const totalTrips = await this.prisma.dateTravelOrder.count({
        where: {
          driverId: row.driverId,
          startDate: {
            gte: new Date(startDate),
            lte: new Date(endDate),
          },
          realised: 1,
        },
      });

      const usagePercentage = totalTrips > 0 ? (row.usageCount / totalTrips) * 100 : 0;

      // Confidence score zavisi od:
      // - Broja kori≈°ƒáenja (max 50 bodova)
      // - Procenta kori≈°ƒáenja (max 50 bodova)
      const usageScore = Math.min((row.usageCount / 20) * 50, 50);
      const percentageScore = Math.min((usagePercentage / 50) * 50, 50);
      const confidenceScore = Math.round(usageScore + percentageScore);

      if (confidenceScore >= minConfidenceScore) {
        analysis.push({
          driverId: row.driverId,
          driverName: row.driverName,
          turnusName: row.turnusName,
          lineNumber: row.lineNumber,
          shiftNumber: row.shiftNumber ? parseInt(row.shiftNumber) : null,
          dayOfWeek: row.dayOfWeek as DayOfWeek,
          usageCount: row.usageCount,
          usagePercentage: Math.round(usagePercentage * 100) / 100,
          confidenceScore,
          recommendation: this.getRecommendation(confidenceScore, row.usageCount),
        });
      }
    }

    // Sortiraj po confidence score DESC
    analysis.sort((a, b) => b.confidenceScore - a.confidenceScore);

    return analysis;
  }

  /**
   * Mapira prikazni broj linije u interni broj iz price_tables_index tabele
   * Uzima u obzir datum va≈æenja cenovnika i status (A = Active)
   */
  private async getInternalLineNumber(
    lineNumberForDisplay: string,
    connection: mysql.Connection,
    startDate?: string,
    endDate?: string,
  ): Promise<string> {
    try {
      // DIJAGNOSTIKA: Proveri sve verzije cenovnika za display broj
      this.logger.log(`=== MAPIRANJE LINIJE ${lineNumberForDisplay} ===`);
      const [allVersions] = await connection.execute(
        `SELECT line_number, line_number_for_display, date_valid_from, status, line_title
         FROM price_tables_index
         WHERE line_number_for_display = ?
         ORDER BY date_valid_from DESC`,
        [lineNumberForDisplay],
      );

      this.logger.log(`Pronaƒëeno ${(allVersions as any[]).length} verzija cenovnika:`);
      (allVersions as any[]).forEach((v, idx) => {
        this.logger.log(`  ${idx + 1}. line_number="${v.line_number}", date_valid_from="${v.date_valid_from}", status="${v.status}", title="${v.line_title}"`);
      });

      // Ako imamo period, naƒëi verziju koja va≈æi u tom periodu
      let query = `SELECT line_number FROM price_tables_index WHERE line_number_for_display = ? AND status = 'A'`;
      const params: any[] = [lineNumberForDisplay];

      if (startDate) {
        // Naƒëi najnoviju verziju koja va≈æi pre ili na poƒçetak perioda
        query += ` AND date_valid_from <= ?`;
        params.push(startDate);
      }

      query += ` ORDER BY date_valid_from DESC LIMIT 1`;

      const [rows] = await connection.execute(query, params);

      if ((rows as any[]).length > 0) {
        const internalNumber = (rows as any[])[0].line_number;
        this.logger.log(
          `‚úÖ Mapiranje: display="${lineNumberForDisplay}" -> internal="${internalNumber}" (status=A, va≈æi za period)`,
        );
        return internalNumber;
      }

      // Fallback: probaj bilo koju aktivnu verziju
      const [fallbackRows] = await connection.execute(
        `SELECT line_number FROM price_tables_index WHERE line_number_for_display = ? AND status = 'A' ORDER BY date_valid_from DESC LIMIT 1`,
        [lineNumberForDisplay],
      );

      if ((fallbackRows as any[]).length > 0) {
        const internalNumber = (fallbackRows as any[])[0].line_number;
        this.logger.warn(
          `‚ö†Ô∏è Fallback mapiranje: display="${lineNumberForDisplay}" -> internal="${internalNumber}" (najnovija aktivna verzija)`,
        );
        return internalNumber;
      }

      this.logger.warn(
        `‚ùå Mapiranje za liniju "${lineNumberForDisplay}" nije pronaƒëeno, koristim originalni broj`,
      );
      return lineNumberForDisplay; // Fallback na originalni broj
    } catch (error) {
      this.logger.warn(
        `Gre≈°ka pri mapiranju linije ${lineNumberForDisplay}: ${error.message}`,
      );
      return lineNumberForDisplay; // Fallback u sluƒçaju gre≈°ke
    }
  }

  /**
   * Analizira istoriju vo≈ænji iz legacy baze
   */
  private async analyzeHistoryFromLegacy(
    dto: AnalyzeHistoryDto,
    userId: number,
  ): Promise<HistoryAnalysisResult[]> {
    const {
      startDate,
      endDate,
      driverId,
      driverIds,
      minUsageCount = 5,
      minConfidenceScore = 70,
      legacyDatabaseId,
      lineNumber,
    } = dto;

    let connection: mysql.Connection | null = null;

    try {
      // Validacija: legacyDatabaseId je obavezan za legacy source
      if (!legacyDatabaseId) {
        throw new BadRequestException(
          'Legacy Database ID je obavezan kada je izabran Legacy izvor',
        );
      }

      // Dohvati kredencijale legacy baze
      const legacyDb = await this.prisma.legacyDatabase.findUnique({
        where: { id: legacyDatabaseId },
      });

      if (!legacyDb) {
        throw new NotFoundException(
          `Legacy baza sa ID ${legacyDatabaseId} nije pronaƒëena`,
        );
      }

      if (!legacyDb.isActive) {
        throw new BadRequestException(
          `Legacy baza "${legacyDb.name}" nije aktivna`,
        );
      }

      this.logger.log(
        `Povezivanje na legacy bazu: ${legacyDb.name} (${legacyDb.host}:${legacyDb.port}/${legacyDb.database})`,
      );

      // Dekriptuj password
      const password =
        this.legacyDatabasesService.decryptPassword(legacyDb.password);

      // Kreiraj konekciju
      connection = await mysql.createConnection({
        host: legacyDb.host,
        port: legacyDb.port,
        user: legacyDb.username,
        password: password,
        database: legacyDb.database,
      });

      this.logger.log('Uspe≈°no povezano na legacy bazu');

      // Konstrui≈°i WHERE klauzulu za filtriranje vozaƒça
      let driverFilter = '';
      if (driverId) {
        driverFilter = `AND dto.driver_id = ${driverId}`;
      } else if (driverIds && driverIds.length > 0) {
        driverFilter = `AND dto.driver_id IN (${driverIds.join(',')})`;
      }

      // Konstrui≈°i WHERE klauzulu za filtriranje po liniji
      // Prvo mapiramo prikazni broj u interni broj
      let lineFilter = '';
      let internalLineNo: string | null = null;
      if (lineNumber) {
        internalLineNo = await this.getInternalLineNumber(
          lineNumber,
          connection,
          startDate,
          endDate,
        );
        lineFilter = `AND dto.line_no = '${internalLineNo}'`;

        // DIJAGNOSTIKA: Proveri da li linija postoji u date_travel_order
        this.logger.log('=== DIJAGNOSTIKA LINIJE ===');
        const [lineExistsResult] = await connection.execute(
          `SELECT COUNT(*) as cnt FROM date_travel_order
           WHERE line_no = ?
           AND start_date BETWEEN ? AND ?
           AND realised = 1`,
          [internalLineNo, startDate, endDate],
        );
        const lineCount = (lineExistsResult as any[])[0].cnt;
        this.logger.log(`Linija "${internalLineNo}" u periodu: ${lineCount} vo≈ænji`);

        // DIJAGNOSTIKA: Proveri strukturu i sadr≈æaj date_travel_order
        const [dtoSample] = await connection.execute(
          `SELECT shedule_id, line_no, driver_id, start_date
           FROM date_travel_order
           WHERE line_no = ?
           AND start_date BETWEEN ? AND ?
           AND realised = 1
           LIMIT 3`,
          [internalLineNo, startDate, endDate],
        );
        this.logger.log('Primeri redova iz date_travel_order:');
        (dtoSample as any[]).forEach((row, idx) => {
          this.logger.log(`  ${idx + 1}. shedule_id="${row.shedule_id}", line_no="${row.line_no}", driver_id="${row.driver_id}"`);
        });

        // DIJAGNOSTIKA: Proveri strukturu date_shedule tabele
        this.logger.log('=== PROVERA STRUKTURE date_shedule ===');
        const [dsColumns] = await connection.execute(
          `SHOW COLUMNS FROM date_shedule`,
        );
        this.logger.log(`Kolone u date_shedule: ${(dsColumns as any[]).map((c: any) => c.Field).join(', ')}`);

        // Proveri primere podataka iz date_shedule
        const [dsSamples] = await connection.execute(
          `SELECT * FROM date_shedule LIMIT 3`,
        );
        this.logger.log('Primeri redova iz date_shedule:');
        (dsSamples as any[]).forEach((row: any, idx: number) => {
          this.logger.log(`  ${idx + 1}. ${JSON.stringify(row).substring(0, 300)}...`);
        });

        // DIJAGNOSTIKA: Proveri strukturu changes_codes_tours tabele
        this.logger.log('=== PROVERA STRUKTURE changes_codes_tours ===');
        const [cctColumns] = await connection.execute(
          `SHOW COLUMNS FROM changes_codes_tours`,
        );
        this.logger.log(`Kolone u changes_codes_tours: ${(cctColumns as any[]).map((c: any) => c.Field).join(', ')}`);

        // Proveri primere podataka iz changes_codes_tours
        const [cctSamples] = await connection.execute(
          `SELECT * FROM changes_codes_tours LIMIT 3`,
        );
        this.logger.log('Primeri redova iz changes_codes_tours:');
        (cctSamples as any[]).forEach((row: any, idx: number) => {
          this.logger.log(`  ${idx + 1}. ${JSON.stringify(row).substring(0, 300)}...`);
        });

        // DIJAGNOSTIKA: Proveri vezu izmeƒëu tabela preko date_shedule
        if ((dtoSample as any[]).length > 0) {
          const sheduleIds = (dtoSample as any[]).map((r: any) => r.shedule_id).filter((id: any) => id !== null);
          if (sheduleIds.length > 0) {
            this.logger.log(`=== PROVERA VEZE PREKO date_shedule ===`);
            this.logger.log(`shedule_id iz date_travel_order: ${sheduleIds.join(', ')}`);

            // Proveri da li ti shedule_id postoje u date_shedule
            const [dsCheck] = await connection.execute(
              `SELECT id, tour_id FROM date_shedule WHERE id IN (${sheduleIds.map(() => '?').join(',')}) LIMIT 5`,
              sheduleIds,
            );
            this.logger.log(`date_shedule WHERE id IN (...): ${(dsCheck as any[]).length} redova`);
            (dsCheck as any[]).forEach((row: any, idx: number) => {
              this.logger.log(`  ${idx + 1}. id="${row.id}", tour_id="${row.tour_id}"`);
            });

            // Ako imamo tour_id, proveri u changes_codes_tours
            if ((dsCheck as any[]).length > 0) {
              const tourIds = (dsCheck as any[]).map((r: any) => r.tour_id).filter((id: any) => id !== null);
              if (tourIds.length > 0) {
                const [cctCheck] = await connection.execute(
                  `SELECT turnus_id, turnus_name, shift_number
                   FROM changes_codes_tours
                   WHERE turnus_id IN (${tourIds.map(() => '?').join(',')})
                   LIMIT 5`,
                  tourIds,
                );
                this.logger.log(`changes_codes_tours WHERE turnus_id IN (...): ${(cctCheck as any[]).length} redova`);
                (cctCheck as any[]).forEach((row: any, idx: number) => {
                  this.logger.log(`  ${idx + 1}. turnus_id="${row.turnus_id}", turnus_name="${row.turnus_name}", shift="${row.shift_number}"`);
                });
              }
            }
          } else {
            this.logger.warn('‚ö†Ô∏è shedule_id je NULL u svim primerima!');
          }
        }

        // DIJAGNOSTIKA: Proveri JOIN preko date_shedule
        const [joinTestResult] = await connection.execute(
          `SELECT COUNT(*) as cnt
           FROM date_travel_order dto
           INNER JOIN date_shedule ds ON dto.shedule_id = ds.id
           INNER JOIN changes_codes_tours cct ON ds.tour_id = cct.turnus_id
           WHERE dto.line_no = ?
           AND dto.start_date BETWEEN ? AND ?
           AND dto.realised = 1`,
          [internalLineNo, startDate, endDate],
        );
        const joinCount = (joinTestResult as any[])[0].cnt;
        this.logger.log(`Uspe≈°an JOIN preko date_shedule: ${joinCount} redova`);

        // DIJAGNOSTIKA: Proveri koliko redova ima sa user JOIN-om
        const [userJoinResult] = await connection.execute(
          `SELECT COUNT(*) as cnt
           FROM date_travel_order dto
           INNER JOIN users u ON dto.driver_id = u.id
           INNER JOIN date_shedule ds ON dto.shedule_id = ds.id
           INNER JOIN changes_codes_tours cct ON ds.tour_id = cct.turnus_id
           WHERE dto.line_no = ?
           AND dto.start_date BETWEEN ? AND ?
           AND dto.realised = 1`,
          [internalLineNo, startDate, endDate],
        );
        const userJoinCount = (userJoinResult as any[])[0].cnt;
        this.logger.log(`Sa users JOIN-om: ${userJoinCount} redova`);

        // DIJAGNOSTIKA: Proveri koliko redova ima sa turnus_name IS NOT NULL filterom
        const [turnusFilterResult] = await connection.execute(
          `SELECT COUNT(*) as cnt
           FROM date_travel_order dto
           INNER JOIN users u ON dto.driver_id = u.id
           INNER JOIN date_shedule ds ON dto.shedule_id = ds.id
           INNER JOIN changes_codes_tours cct ON ds.tour_id = cct.turnus_id
           WHERE dto.line_no = ?
           AND dto.start_date BETWEEN ? AND ?
           AND dto.realised = 1
           AND cct.turnus_name IS NOT NULL
           AND cct.turnus_name != ''`,
          [internalLineNo, startDate, endDate],
        );
        const turnusFilterCount = (turnusFilterResult as any[])[0].cnt;
        this.logger.log(`Sa turnus_name filterom: ${turnusFilterCount} redova`);

        this.logger.log('=== KRAJ DIJAGNOSTIKE ===');
      }

      // Query za analizu iz legacy baze - koristi JOIN preko date_shedule tabele
      const legacyQuery = `
        SELECT
          dto.driver_id as driverId,
          CONCAT(u.first_name, ' ', u.last_name) as driverName,
          cct.turnus_name as turnusName,
          dto.line_no as lineNumber,
          cct.shift_number as shiftNumber,
          CASE DAYOFWEEK(dto.start_date)
            WHEN 1 THEN 'Nedelja'
            WHEN 2 THEN 'Ponedeljak'
            WHEN 3 THEN 'Utorak'
            WHEN 4 THEN 'Sreda'
            WHEN 5 THEN 'ƒåetvrtak'
            WHEN 6 THEN 'Petak'
            WHEN 7 THEN 'Subota'
          END as dayOfWeek,
          COUNT(*) as usageCount
        FROM date_travel_order dto
        INNER JOIN users u ON dto.driver_id = u.id
        INNER JOIN date_shedule ds ON dto.shedule_id = ds.id
        INNER JOIN changes_codes_tours cct ON ds.tour_id = cct.turnus_id
        WHERE dto.start_date BETWEEN ? AND ?
          AND dto.realised = 1
          ${driverFilter}
          ${lineFilter}
          AND cct.turnus_name IS NOT NULL
          AND cct.turnus_name != ''
        GROUP BY dto.driver_id, turnusName, dto.line_no, shiftNumber, dayOfWeek
        HAVING usageCount >= ${minUsageCount}
      `;

      this.logger.log(`Izvr≈°avam analizu za period: ${startDate} - ${endDate}`);

      // DIJAGNOSTIKA: Proveri primere podataka BEZ GROUP BY
      if (internalLineNo) {
        this.logger.log('=== DIJAGNOSTIKA: Primeri redova BEZ GROUP BY ===');
        const sampleQuery = `
          SELECT
            dto.driver_id,
            CONCAT(u.first_name, ' ', u.last_name) as driverName,
            cct.turnus_name,
            dto.line_no,
            cct.shift_number,
            dto.start_date,
            dto.shedule_id,
            ds.id as date_shedule_id,
            ds.tour_id,
            cct.turnus_id
          FROM date_travel_order dto
          INNER JOIN users u ON dto.driver_id = u.id
          INNER JOIN date_shedule ds ON dto.shedule_id = ds.id
          INNER JOIN changes_codes_tours cct ON ds.tour_id = cct.turnus_id
          WHERE dto.line_no = ?
          AND dto.start_date BETWEEN ? AND ?
          AND dto.realised = 1
          AND cct.turnus_name IS NOT NULL
          AND cct.turnus_name != ''
          LIMIT 5
        `;
        const [sampleRows] = await connection.execute(sampleQuery, [
          internalLineNo,
          startDate,
          endDate,
        ]);
        (sampleRows as any[]).forEach((row, idx) => {
          this.logger.log(`  ${idx + 1}. ${JSON.stringify(row)}`);
        });
        this.logger.log('=== KRAJ PRIMERA ===');
      }

      // Izvr≈°avanje glavnog query-a
      const [rows] = await connection.execute(legacyQuery, [startDate, endDate]);

      this.logger.log(`Pronaƒëeno ${(rows as any[]).length} rezultata iz legacy baze nakon GROUP BY`);

      // Izraƒçunaj statistiku i confidence score za svaki rezultat
      const analysis: HistoryAnalysisResult[] = [];

      for (const row of rows as any[]) {
        // Izraƒçunaj ukupan broj vo≈ænji za vozaƒça u periodu iz legacy baze
        const [totalTripsResult] = await connection.execute(
          `SELECT COUNT(*) as total FROM date_travel_order
           WHERE driver_id = ?
           AND start_date BETWEEN ? AND ?
           AND realised = 1`,
          [row.driverId, startDate, endDate],
        );

        const totalTrips = (totalTripsResult as any[])[0].total;
        const usagePercentage =
          totalTrips > 0 ? (row.usageCount / totalTrips) * 100 : 0;

        // Confidence score zavisi od:
        // - Broja kori≈°ƒáenja (max 50 bodova)
        // - Procenta kori≈°ƒáenja (max 50 bodova)
        const usageScore = Math.min((row.usageCount / 20) * 50, 50);
        const percentageScore = Math.min((usagePercentage / 50) * 50, 50);
        const confidenceScore = Math.round(usageScore + percentageScore);

        if (confidenceScore >= minConfidenceScore) {
          analysis.push({
            driverId: row.driverId,
            driverName: row.driverName,
            turnusName: row.turnusName,
            lineNumber: row.lineNumber,
            shiftNumber: row.shiftNumber ? parseInt(row.shiftNumber) : null,
            dayOfWeek: row.dayOfWeek as DayOfWeek,
            usageCount: row.usageCount,
            usagePercentage: Math.round(usagePercentage * 100) / 100,
            confidenceScore,
            recommendation: this.getRecommendation(
              confidenceScore,
              row.usageCount,
            ),
          });
        }
      }

      // Sortiraj po confidence score DESC
      analysis.sort((a, b) => b.confidenceScore - a.confidenceScore);

      this.logger.log(
        `Analiza zavr≈°ena: ${analysis.length} kandidata sa confidence >= ${minConfidenceScore}`,
      );

      return analysis;
    } catch (error: any) {
      this.logger.error('Gre≈°ka pri analizi legacy baze:', error);

      // Bolje error handling za razliƒçite tipove gre≈°aka
      if (error.code === 'ETIMEDOUT') {
        throw new BadRequestException(
          'Konekcija sa Gradskim serverom nije moguƒáa. Server je trenutno nedostupan ili je VPN veza prekinuta.',
        );
      } else if (error.code === 'ECONNREFUSED') {
        throw new BadRequestException(
          'Gradski server je odbio konekciju. Proverite da li je server aktivan.',
        );
      } else if (error.code === 'ER_ACCESS_DENIED_ERROR') {
        throw new BadRequestException(
          'Pristup Gradskom serveru je odbijen. Proverite kredencijale.',
        );
      } else if (error.code === 'ER_BAD_DB_ERROR') {
        throw new BadRequestException(
          `Baza podataka "${dto.legacyDatabaseId}" ne postoji na serveru.`,
        );
      } else if (error.code === 'ER_NO_SUCH_TABLE') {
        throw new BadRequestException(
          'Tabela date_travel_order ili users ne postoji u legacy bazi.',
        );
      }

      throw error;
    } finally {
      if (connection) {
        await connection.end();
        this.logger.log('Konekcija sa legacy bazom zatvorena');
      }
    }
  }

  /**
   * Generi≈°e defaults na osnovu analize istorije
   */
  async generateDefaults(dto: AnalyzeHistoryDto, userId: number) {
    this.logger.log('=== POƒåETAK GENERISANJA DEFAULTS ===');
    const analysis = await this.analyzeHistory(dto, userId);

    this.logger.log(`Dobijeno ${analysis.length} kandidata iz analize`);

    const created: Array<HistoryAnalysisResult & { defaultId: number }> = [];
    const skipped: Array<HistoryAnalysisResult & { reason: string }> = [];

    let processedCount = 0;

    // Ako je source=legacy, prvo mapiramo sve legacy ID-eve u na≈°e ID-eve
    const isLegacy = dto.source === DataSource.LEGACY;
    const driverIdMap = new Map<number, number>(); // legacy_id -> our_id

    if (isLegacy) {
      this.logger.log('Detektovan legacy source - mapiram driver ID-eve...');
      const uniqueDriverIds = [...new Set(analysis.map(item => item.driverId))];

      for (const legacyId of uniqueDriverIds) {
        const user = await this.prisma.user.findUnique({
          where: { legacyId },
          select: { id: true, firstName: true, lastName: true, legacyId: true },
        });

        if (user) {
          driverIdMap.set(legacyId, user.id);
          this.logger.log(`  ‚úÖ Legacy ID ${legacyId} ‚Üí Na≈° ID ${user.id} (${user.firstName} ${user.lastName})`);
        } else {
          this.logger.warn(`  ‚ö†Ô∏è Legacy ID ${legacyId} ne postoji u na≈°oj bazi!`);
        }
      }

      this.logger.log(`Mapirano ${driverIdMap.size}/${uniqueDriverIds.length} vozaƒça\n`);
    }

    for (const item of analysis) {
      processedCount++;
      this.logger.log(`\n[${processedCount}/${analysis.length}] Obraƒëujem: ${item.driverName} - ${item.turnusName}`);

      try {
        // Mapiranje driver ID-a ako je legacy source
        let actualDriverId = item.driverId;

        if (isLegacy) {
          const mappedId = driverIdMap.get(item.driverId);
          if (!mappedId) {
            this.logger.warn(`  ‚è≠Ô∏è  Preskaƒáem - vozaƒç sa legacy ID ${item.driverId} ne postoji u na≈°oj bazi`);
            skipped.push({
              ...item,
              reason: `Vozaƒç sa legacy ID ${item.driverId} ne postoji u na≈°oj bazi`,
            });
            continue;
          }
          actualDriverId = mappedId;
          this.logger.log(`  üîÑ Mapirano: legacy ID ${item.driverId} ‚Üí na≈° ID ${actualDriverId}`);
        }

        // Proveri da li veƒá postoji default sa istim parametrima
        this.logger.log(`  Proveravam da li veƒá postoji default...`);
        const existing = await this.prisma.turnusDefaultPerDriver.findFirst({
          where: {
            driverId: actualDriverId,
            turnusName: item.turnusName,
            lineNumberForDisplay: item.lineNumber,
            shiftNumber: item.shiftNumber,
            dayOfWeek: item.dayOfWeek,
          },
        });

        if (existing) {
          this.logger.log(`  ‚è≠Ô∏è  Preskaƒáem - veƒá postoji default sa ID ${existing.id}`);
          skipped.push({
            ...item,
            reason: 'Veƒá postoji default sa istim parametrima',
          });
          continue;
        }

        this.logger.log(`  ‚úÖ Default ne postoji, kreiram novi...`);

        // Kreiraj novi default sa NA≈†IM driver ID-om
        const newDefault = await this.create(
          {
            driverId: actualDriverId,
            turnusName: item.turnusName,
            lineNumberForDisplay: item.lineNumber ?? undefined,
            shiftNumber: item.shiftNumber ?? undefined,
            dayOfWeek: item.dayOfWeek ?? undefined,
          },
          userId,
        );

        this.logger.log(`  ‚úÖ Default kreiran sa ID ${newDefault.id}`);

        // A≈æuriraj statistiku
        this.logger.log(`  A≈æuriram statistiku...`);
        await this.prisma.turnusDefaultPerDriver.update({
          where: { id: newDefault.id },
          data: {
            usageCount: item.usageCount,
            usagePercentage: item.usagePercentage,
            confidenceScore: item.confidenceScore,
            autoGenerated: true,
          },
        });

        this.logger.log(`  ‚úÖ Statistika a≈æurirana`);

        created.push({
          ...item,
          defaultId: newDefault.id,
        });
      } catch (error) {
        this.logger.error(`  ‚ùå GRE≈†KA: ${error.message}`);
        this.logger.error(`  Stack trace: ${error.stack}`);
        skipped.push({
          ...item,
          reason: error.message,
        });
      }
    }

    this.logger.log('\n=== KRAJ GENERISANJA DEFAULTS ===');
    this.logger.log(`Kreirano: ${created.length}`);
    this.logger.log(`Preskoƒçeno: ${skipped.length}`);

    if (skipped.length > 0) {
      this.logger.log('\n=== RAZLOZI ZA PRESKAKANJE (prvih 10) ===');
      skipped.slice(0, 10).forEach((item, idx) => {
        this.logger.log(`${idx + 1}. ${item.driverName} - ${item.turnusName}: ${item.reason}`);
      });
    }

    return {
      success: true,
      analyzed: analysis.length,
      created: created.length,
      skipped: skipped.length,
      details: {
        created,
        skipped,
      },
    };
  }

  /**
   * Izraƒçunava prioritet na osnovu nivoa specifiƒçnosti
   * Nivo 1 (najvi≈°i prioritet): turnus + linija + smena + dan = 10
   * Nivo 2: turnus + linija + smena = 30
   * Nivo 3: turnus + linija + dan = 50
   * Nivo 4: turnus + smena + dan = 70
   * Nivo 5: turnus + linija = 100
   * Nivo 6: turnus + smena = 120
   * Nivo 7: turnus + dan = 140
   * Nivo 8 (fallback): samo turnus = 200
   */
  private calculatePriority(
    lineNumber?: string | null,
    shiftNumber?: number | null,
    dayOfWeek?: DayOfWeek | null,
  ): number {
    const hasLine = !!lineNumber;
    const hasShift = shiftNumber !== null && shiftNumber !== undefined;
    const hasDay = !!dayOfWeek;

    if (hasLine && hasShift && hasDay) return 10; // Level 1
    if (hasLine && hasShift) return 30; // Level 2
    if (hasLine && hasDay) return 50; // Level 3
    if (hasShift && hasDay) return 70; // Level 4
    if (hasLine) return 100; // Level 5
    if (hasShift) return 120; // Level 6
    if (hasDay) return 140; // Level 7
    return 200; // Level 8 - fallback
  }

  /**
   * Generi≈°e preporuku na osnovu confidence score-a
   */
  private getRecommendation(confidenceScore: number, usageCount: number): string {
    if (confidenceScore >= 90 && usageCount >= 15) {
      return 'VISOKA PREPORUKA - Vrlo konzistentan pattern';
    } else if (confidenceScore >= 80 && usageCount >= 10) {
      return 'PREPORUƒåENO - Stabilan pattern';
    } else if (confidenceScore >= 70 && usageCount >= 5) {
      return 'UMJERENA PREPORUKA - Pattern postoji ali treba praƒáenje';
    } else {
      return 'NISKA PREPORUKA - Nedovoljno podataka';
    }
  }
}
